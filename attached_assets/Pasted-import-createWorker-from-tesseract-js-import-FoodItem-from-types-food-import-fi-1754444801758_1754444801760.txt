import { createWorker } from 'tesseract.js';
import { FoodItem } from '../types/food';
import { findFoodItem } from '../data/foodDatabase';

// ============= OCR CORRECTION UTILITIES =============
export class OCRCorrection {
  
  // Common OCR errors and their corrections
  private static corrections: Record<string, string> = {
    // Common letter substitutions
    'watrmelon': 'watermelon',
    'watennelon': 'watermelon',
    'waterrnekm': 'watermelon',
    'elon': 'melon',
    'banna': 'banana',
    'bananna': 'banana',
    'bannana': 'banana',
    'banan': 'banana',
    'appl': 'apple',
    'aple': 'apple',
    'organe': 'orange',
    'orang': 'orange',
    'orangs': 'orange',
    'tomatoe': 'tomato',
    'tormato': 'tomato',
    'potatos': 'potato',
    'potatoe': 'potato',
    'onions': 'onion',
    'carrots': 'carrot',
    'chickin': 'chicken',
    'chiken': 'chicken',
    'chickn': 'chicken',
    'beaf': 'beef',
    'hamm': 'ham',
    'bakon': 'bacon',
    'egss': 'eggs',
    'egges': 'eggs',
    'milkk': 'milk',
    'chees': 'cheese',
    'cheeze': 'cheese',
    'buttr': 'butter',
    'butterr': 'butter',
    'bred': 'bread',
    'breadd': 'bread',
    'riee': 'rice',
    'riec': 'rice',
    'cereall': 'cereal',
    'cerael': 'cereal',
    'yoghurt': 'yogurt',
    'yougurt': 'yogurt',
    
    // Common OCR character confusions
    'rn': 'm',
    'ln': 'h',
    'cl': 'd',
    'ii': 'll',
    '1l': 'll',
    'l1': 'll',
    '0': 'o',
    '5': 's',
    '6': 'g',
    '8': 'b'
  };

  static correctItemName(itemName: string): string {
    let corrected = itemName.toLowerCase().trim();
    
    // Apply direct corrections
    if (this.corrections[corrected]) {
      return this.corrections[corrected];
    }
    
    // Apply character-level corrections
    let result = corrected;
    for (const [wrong, correct] of Object.entries(this.corrections)) {
      if (wrong.length <= 2 && correct.length <= 2) { // Character substitutions
        result = result.replace(new RegExp(wrong, 'g'), correct);
      }
    }
    
    // Fix common patterns
    result = this.fixCommonPatterns(result);
    
    return result;
  }
  
  private static fixCommonPatterns(text: string): string {
    let result = text;
    
    // Fix doubled letters that should be single
    result = result.replace(/(.)\1{2,}/g, '$1$1'); // Keep max 2 of same letter
    
    // Fix common word endings
    result = result.replace(/rn/g, 'm'); // 'rn' often misread as 'm'
    result = result.replace(/ln/g, 'h'); // 'ln' often misread as 'h'
    
    // Fix spacing issues
    result = result.replace(/\s+/g, ' '); // Multiple spaces to single
    result = result.trim();
    
    return result;
  }
  
  static isLikelyMisread(itemName: string): boolean {
    const suspicious = [
      /^[a-z]{1,2}$/i, // Too short
      /^re$/i, // Common OCR fragment
      /^[a-z]{1,3}\s+[a-z]{1,3}$/i, // Two very short words
      /[a-z]{5,}[0-9]+[a-z]*/i, // Letters mixed with numbers
      /^[^aeiou]{3,}/i, // Too many consonants
      /[aeiou]{4,}/i, // Too many vowels together
    ];
    
    return suspicious.some(pattern => pattern.test(itemName));
  }
}

// ============= RECEIPT FILTERS =============
export class ReceiptFilters {
  
  static hasPrice(line: string): boolean {
    // Common price patterns (flexible to handle OCR errors)
    const pricePatterns = [
      /\$\s*\d+\.?\d*/,     // $1.99, $ 1.99, $1
      /\d+\.\d{2}\s*$/,     // 1.99 at end of line
      /\d+\s*@\s*\d+/,      // 2 @ 1.99
      /\d+\.\d{2}\s*[A-Z]/, // 1.99 F (with flag)
      /\b\d{1,3}\.\d{2}\b/, // General decimal price
    ];
    
    return pricePatterns.some(pattern => pattern.test(line));
  }

  static isNonFoodLine(line: string): boolean {
    // Comprehensive patterns for non-food lines
    const nonFoodPatterns = [
      // Payment and totals
      /^(SUB)?TOTAL/i,
      /^TAX/i,
      /^CASH|CHANGE|CREDIT|DEBIT|PAYMENT/i,
      /^BALANCE|AMOUNT/i,
      /^VISA|MASTERCARD|AMEX/i,
      
      // Store info and receipt metadata  
      /STORE|LOCATION|ADDRESS/i,
      /PHONE|TEL:|FAX/i,
      /THANK\s+YOU|THANKS/i,
      /RECEIPT|TRANSACTION/i,
      /CASHIER|CLERK|OPERATOR/i,
      /REGISTER|LANE/i,
      
      // Date and time patterns
      /^\d{1,2}\/\d{1,2}\/\d{2,4}/,
      /^\d{1,2}:\d{2}/,
      /^(MON|TUE|WED|THU|FRI|SAT|SUN)/i,
      
      // Customer service and promotions
      /CUSTOMER\s+SERVICE/i,
      /SATISFACTION\s+GUARANTEED/i,
      /RETURN\s+POLICY/i,
      /COUPON|DISCOUNT|SAVE/i,
      /SPECIAL\s+OFFER/i,
      
      // Non-food household items
      /TISSUE|TOILET\s+PAPER|TOWEL/i,
      /DETERGENT|SOAP|SHAMPOO/i,
      /BATTERY|BATTERIES/i,
      /MEDICINE|PHARMACY/i,
      
      // Common OCR artifacts and noise
      /^[\*\-\=\+]{3,}/,    // Decorative characters
      /^\s*[A-Z]\s*$/,      // Single letters
      /^\d+\s*$/,           // Just numbers
      /^[^a-zA-Z]*$/,       // No letters at all
      
      // Receipt footer patterns
      /VISIT\s+US|FOLLOW\s+US/i,
      /FACEBOOK|TWITTER|INSTAGRAM/i,
      /\.COM|WWW\./i,
      /SURVEY|FEEDBACK/i,
    ];
    
    return nonFoodPatterns.some(pattern => pattern.test(line));
  }

  static isValidItemName(name: string): boolean {
    // Must have minimum length
    if (name.length < 2) return false;
    
    // Must contain at least one letter
    if (!/[a-zA-Z]/.test(name)) return false;
    
    // Must contain at least one vowel (or y)
    if (!/[aeiouy]/i.test(name)) return false;
    
    // Should be mostly alphabetic
    const alphaRatio = (name.match(/[a-zA-Z]/g) || []).length / name.length;
    if (alphaRatio < 0.6) return false;
    
    // Reject common OCR garbage patterns
    const garbagePatterns = [
      /^[^aeiou]{4,}$/i,    // Too many consonants
      /^[aeiou]{3,}$/i,     // Too many vowels
      /(.)\1{3,}/,          // Too many repeated characters
      /^(re|er|en|an|el|le|te|et|se|es|st|ts)$/i, // Common OCR fragments
    ];
    
    if (garbagePatterns.some(pattern => pattern.test(name))) return false;
    
    // Reject if too much capitalization (likely OCR error)
    const upperRatio = (name.match(/[A-Z]/g) || []).length / name.length;
    if (upperRatio > 0.7 && name.length > 3) return false;
    
    return true;
  }

  static isLikelyFoodItem(itemName: string): boolean {
    const name = itemName.toLowerCase();
    
    // Strong food keywords
    const foodKeywords = [
      // Fruits
      'apple', 'banana', 'orange', 'grape', 'berry', 'melon', 'peach', 'pear', 'cherry', 'plum',
      'lemon', 'lime', 'kiwi', 'mango', 'pineapple', 'strawberry', 'blueberry', 'raspberry',
      
      // Vegetables  
      'carrot', 'potato', 'onion', 'tomato', 'lettuce', 'spinach', 'broccoli', 'pepper', 'corn',
      'bean', 'pea', 'cucumber', 'celery', 'cabbage', 'mushroom',
      
      // Proteins
      'chicken', 'beef', 'pork', 'fish', 'salmon', 'tuna', 'turkey', 'ham', 'bacon', 'egg',
      'cheese', 'yogurt', 'milk',
      
      // Grains and pantry
      'bread', 'rice', 'pasta', 'cereal', 'flour', 'oat', 'wheat', 'bagel', 'muffin',
      
      // Common food terms
      'food', 'fresh', 'organic', 'natural'
    ];
    
    // Non-food keywords (should exclude)
    const nonFoodKeywords = [
      'battery', 'soap', 'shampoo', 'detergent', 'tissue', 'paper', 'towel',
      'medicine', 'vitamin', 'supplement', 'cleaner', 'bag', 'receipt'
    ];
    
    // Check for non-food keywords first
    if (nonFoodKeywords.some(keyword => name.includes(keyword))) {
      return false;
    }
    
    // Check for food keywords
    if (foodKeywords.some(keyword => name.includes(keyword))) {
      return true;
    }
    
    // Additional heuristics for unknown items
    // Reasonable length (not too short or too long)
    if (name.length < 3 || name.length > 25) return false;
    
    // Has enough vowels
    const vowelCount = (name.match(/[aeiouy]/g) || []).length;
    if (vowelCount < 2) return false;
    
    // Mostly alphabetic
    const alphaRatio = (name.match(/[a-zA-Z]/g) || []).length / name.length;
    if (alphaRatio < 0.7) return false;
    
    return true; // Default to including if it passes basic checks
  }
}

// ============= SMART PARSER =============
export interface ParsedReceiptLine {
  itemName: string;
  quantity: string;
  price: string;
  weight?: string;
  isVerifiedFood: boolean;
}

export class SmartParser {
  
  static parseAnyLine(line: string): ParsedReceiptLine | null {
    // Smart parser that tries to extract meaningful food items while filtering OCR noise
    const originalLine = line.trim();
    
    // Skip obviously bad lines - much stricter
    if (originalLine.length < 6) return null;
    if (/^[\d\s\-\*\=\.]+$/.test(originalLine)) return null;
    
    // Skip lines with excessive special characters or OCR artifacts
    const specialCharCount = (originalLine.match(/[^a-zA-Z0-9\s]/g) || []).length;
    if (specialCharCount > originalLine.length * 0.4) return null;
    
    // Skip lines that are clearly OCR garbage or store operations
    if (/employee|discount|senior|wessel|enployel|bpddbbiannnatiIl|torpc|saved|pub|ben|poy|ere|rg|eba|aten|aal|ene|hase|saat|stn|bias|ett|laid|selhad|alr|rest\s+style/i.test(originalLine)) return null;
    
    // Skip lines that look like OCR garbage (too many single letters)
    const words = originalLine.split(/\s+/);
    const singleLetterWords = words.filter(word => word.length === 1).length;
    if (singleLetterWords > words.length * 0.3) return null;
    
    let itemName = '';
    let quantity = '1';
    let isVerifiedFood = false;
    
    // Extract quantity from patterns like "2 @ 0.37" or "3 for $1.00"
    const quantityAtPriceMatch = originalLine.match(/(\d+)\s*[@x]\s*[\$]?\d+\.?\d*/i);
    if (quantityAtPriceMatch) {
      quantity = quantityAtPriceMatch[1];
      itemName = originalLine.replace(/\d+\s*[@x]\s*[\$]?\d+\.?\d*/i, '').trim();
      isVerifiedFood = true;
    } else {
      // Look for explicit quantity mentions
      const qtyMatch = originalLine.match(/qty[\s:]*(\d+)/i) || originalLine.match(/(\d+)\s*qty/i);
      if (qtyMatch) {
        quantity = qtyMatch[1];
        itemName = originalLine.replace(/qty[\s:]*\d+/i, '').replace(/\d+\s*qty/i, '').trim();
      } else {
        // Remove all prices, weights, and numeric patterns except quantity
        itemName = originalLine
          .replace(/\$\d+\.?\d*/g, '') // Remove prices with $
          .replace(/\d+\.?\d*\s*lb/gi, '') // Remove weight measurements
          .replace(/\b\d+\.?\d{2}\b/g, '') // Remove decimal numbers (prices)
          .replace(/\b[A-Z]\s*$/g, '') // Remove single letters at end (flags like F, N, T)
          .replace(/\b(PC|WT|SC|F|N|T|A)\b/gi, '') // Remove abbreviations
          .replace(/\b\d{3,}\b/g, '') // Remove long numeric codes
          .replace(/[@x]\s*\d+/gi, '') // Remove @ patterns
          .trim();
      }
    }
    
    // Look for food indicators
    const foodIndicators = ['F', 'N', 'T', 'A'];
    if (foodIndicators.some(flag => originalLine.includes(` ${flag} `) || originalLine.endsWith(` ${flag}`))) {
      isVerifiedFood = true;
    }
    
    // Look for weight indicators (usually food)
    if (/\d+\.?\d*\s*lb/i.test(originalLine)) {
      isVerifiedFood = true;
    }
    
    // Look for PLU codes (4-5 digits, usually produce)  
    if (/^\d{4,5}/.test(originalLine)) {
      isVerifiedFood = true;
    }
    
    // Clean up the item name
    itemName = this.cleanSmartName(itemName);
    
    if (itemName.length < 3) return null;
    
    return {
      itemName,
      quantity,
      price: '0.00', // Ignore prices as requested
      isVerifiedFood
    };
  }
  
  private static cleanSmartName(name: string): string {
    return name
      .replace(/\b(KRO|KROGER|WALMART|WM|TARGET|TGT|SAFEWAY|SWY|ALDI)\b/gi, '') // Remove store names
      .replace(/\b(ORGANIC|FRESH|FROZEN|CANNED|NATURAL|PREMIUM|SELECT|GREAT VALUE|GV|PC|SS)\b/gi, '') // Remove adjectives  
      .replace(/\b(EACH|EA|PKG|PACKAGE|BAG|BOX|BOTTLE|CAN|JAR|CT|COUNT|LB|LBS|OZ|WT|SC)\b/gi, '') // Remove packaging
      .replace(/\b\d+\b/g, '') // Remove ALL standalone numbers
      .replace(/\d+/g, '') // Remove any remaining numbers
      .replace(/[^\w\s]/g, ' ') // Remove special characters
      .replace(/\s+/g, ' ') // Normalize whitespace
      // Fix common OCR errors to make names more readable
      .replace(/\bmawt\b/gi, 'malt') // Common OCR error
      .replace(/\bbc\b/gi, '') // Remove random letters
      .replace(/\bb\b/gi, '') // Remove single letters
      .replace(/\bo\b/gi, '') // Remove single letters
      .replace(/\boo\b/gi, '') // Remove OCR artifacts
      .replace(/\s+/g, ' ') // Normalize whitespace again
      .trim();
  }
}

// ============= RECEIPT PARSERS =============
export class ReceiptParsers {
  
  static parseKrogerLine(line: string): ParsedReceiptLine | null {
    // Kroger receipt patterns
    const patterns = [
      // Standard format: ITEM NAME QTY @ PRICE FLAG
      /^(.+?)\s+(\d+)\s*@\s*(\d+\.?\d*)\s*([FNT])?.*$/,
      // Weight format: ITEM NAME WEIGHT lb @ PRICE/lb TOTAL FLAG  
      /^(.+?)\s+(\d+\.?\d*)\s*lb\s*@\s*(\d+\.?\d*).*?(\d+\.?\d*)\s*([FNT])?.*$/,
      // PLU format: PLU ITEM NAME WEIGHT @ PRICE TOTAL FLAG
      /^(\d{4,5})\s+(.+?)\s+(\d+\.?\d*)\s*@\s*(\d+\.?\d*).*?(\d+\.?\d*)\s*([FNT])?.*$/,
      // Simple format: ITEM NAME PRICE FLAG
      /^(.+?)\s+(\d+\.?\d*)\s*([FNT]).*$/,
      // Quantity format: ITEM NAME x QTY PRICE
      /^(.+?)\s*x\s*(\d+)\s+(\d+\.?\d*).*$/,
      // Generic with flag: ITEM ... PRICE FLAG
      /^(.+?)\s+.*?(\d+\.?\d*)\s*([FNT])\s*$/
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        let itemName = '';
        let quantity = '1';
        let price = '0.00';
        let isVerifiedFood = false;

        if (pattern === patterns[0]) { // Standard format
          itemName = match[1];
          quantity = match[2];
          price = match[3];
          isVerifiedFood = match[4] === 'F';
        } else if (pattern === patterns[1]) { // Weight format
          itemName = match[1];
          quantity = '1'; // Weight items are typically quantity 1
          price = match[4];
          isVerifiedFood = match[5] === 'F';
        } else if (pattern === patterns[2]) { // PLU format
          itemName = match[2];
          quantity = '1';
          price = match[5];
          isVerifiedFood = match[6] === 'F' || true; // PLU items are usually produce
        } else if (pattern === patterns[3]) { // Simple format
          itemName = match[1];
          quantity = '1';
          price = match[2];
          isVerifiedFood = match[3] === 'F';
        } else if (pattern === patterns[4]) { // Quantity format
          itemName = match[1];
          quantity = match[2];
          price = match[3];
          isVerifiedFood = true; // Quantity items likely food
        } else if (pattern === patterns[5]) { // Generic with flag
          itemName = match[1];
          quantity = '1';
          price = match[2];
          isVerifiedFood = match[3] === 'F';
        }

        itemName = this.cleanItemName(itemName);
        if (itemName.length < 2) continue;

        return {
          itemName,
          quantity,
          price,
          isVerifiedFood
        };
      }
    }

    return null;
  }

  static parseWalmartLine(line: string): ParsedReceiptLine | null {
    // Walmart uses 'N' for non-taxable (often food)
    const match = line.match(/^(.+?)\s+(\d+\.?\d*)\s*N.*$/);
    if (match) {
      const itemName = this.cleanItemName(match[1]);
      if (itemName.length < 2) return null;
      
      return {
        itemName,
        quantity: '1',
        price: match[2],
        isVerifiedFood: true // N flag indicates non-taxable (often food)
      };
    }
    return null;
  }

  static parseTargetLine(line: string): ParsedReceiptLine | null {
    // Target uses 'T' flag
    const match = line.match(/^(.+?)\s+(\d+\.?\d*)\s*T.*$/);
    if (match) {
      const itemName = this.cleanItemName(match[1]);
      if (itemName.length < 2) return null;
      
      return {
        itemName,
        quantity: '1',
        price: match[2],
        isVerifiedFood: true // T flag indicates Target food item
      };
    }
    return null;
  }

  static parseWeightBasedLine(line: string): ParsedReceiptLine | null {
    // Items sold by weight (usually produce)
    const match = line.match(/^(.+?)\s+(\d+\.?\d*)\s*lb\s*@\s*(\d+\.?\d*).*?(\d+\.?\d*).*$/);
    if (match) {
      const itemName = this.cleanItemName(match[1]);
      if (itemName.length < 2) return null;
      
      return {
        itemName,
        quantity: '1', // Weight items typically have quantity 1
        price: match[4],
        weight: match[2] + ' lb',
        isVerifiedFood: true // Weight-based items are usually produce
      };
    }
    return null;
  }

  static parsePLULine(line: string): ParsedReceiptLine | null {
    // PLU codes for produce (4-5 digits at start)
    const match = line.match(/^(\d{4,5})\s+(.+?)\s+(\d+\.?\d*)\s*@?\s*(\d+\.?\d*).*$/);
    if (match) {
      const itemName = this.cleanItemName(match[2]);
      if (itemName.length < 2) return null;
      
      return {
        itemName,
        quantity: '1',
        price: match[4],
        isVerifiedFood: true // PLU items are usually produce
      };
    }
    return null;
  }

  static parseGenericLine(line: string): ParsedReceiptLine | null {
    // Try various generic patterns
    const patterns = [
      // Quantity @ Price format: ITEM QTY @ PRICE
      /^(.+?)\s+(\d+)\s*@\s*(\d+\.?\d*).*$/,
      // Simple price format: ITEM PRICE  
      /^(.+?)\s+(\d+\.?\d*)\s*$/,
      // Price with currency: ITEM $PRICE
      /^(.+?)\s+\$(\d+\.?\d*).*$/,
      // Multiple quantity: ITEM x QTY PRICE
      /^(.+?)\s*x\s*(\d+)\s+(\d+\.?\d*).*$/,
      // ITEM QTY UNIT @ PRICE
      /^(.+?)\s+(\d+)\s+\w+\s+@\s+(\d+\.?\d*).*$/
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        let itemName = '';
        let quantity = '1';
        let price = '0.00';

        if (pattern === patterns[0]) { // Quantity @ Price
          itemName = match[1];
          quantity = match[2];
          price = match[3];
        } else if (pattern === patterns[1]) { // Simple price
          itemName = match[1];
          quantity = '1';
          price = match[2];
        } else if (pattern === patterns[2]) { // Price with currency
          itemName = match[1];
          quantity = '1';
          price = match[2];
        } else if (pattern === patterns[3]) { // Multiple quantity
          itemName = match[1];
          quantity = match[2];
          price = match[3];
        } else if (pattern === patterns[4]) { // ITEM QTY UNIT @ PRICE
          itemName = match[1];
          quantity = match[2];
          price = match[3];
        }

        itemName = this.cleanItemName(itemName);
        if (itemName.length < 2) continue;

        // Check if it's likely a food item
        if (!ReceiptFilters.isLikelyFoodItem(itemName)) continue;

        return {
          itemName,
          quantity,
          price,
          isVerifiedFood: false // Not verified by store flags
        };
      }
    }

    return null;
  }

  private static cleanItemName(name: string): string {
    let cleaned = name
      // Remove prices and quantities first
      .replace(/\$?\d+\.?\d*/g, '') // Remove all numeric values
      .replace(/\b\d+\s*@\s*\d+\.?\d*/g, '') // Remove quantity @ price
      .replace(/\b\d+\s*x\s*\d+\.?\d*/g, '') // Remove quantity x price
      .replace(/\b\d+\.?\d*\s*lb/gi, '') // Remove weight
      .replace(/\bqty\s*:?\s*\d+/gi, '') // Remove quantity labels
      .replace(/\b\d+\s*qty/gi, '') // Remove quantity suffix
      
      // Remove store-specific codes and flags
      .replace(/\b[A-Z]\s*$/g, '') // Remove single letter flags at end
      .replace(/\b(PC|WT|SC|F|N|T|A|PLU)\b/gi, '') // Remove abbreviations
      .replace(/\b\d{3,}\b/g, '') // Remove long numeric codes (UPC, PLU)
      
      // Remove brand and packaging information
      .replace(/\b(KROGER|KRO|WALMART|WM|TARGET|TGT|SAFEWAY|SWY|ALDI)\b/gi, '')
      .replace(/\b(GREAT\s+VALUE|GV|EQUATE|MARKET\s+PANTRY|UP&UP|SIMPLY\s+BALANCED)\b/gi, '')
      .replace(/\b(ORGANIC|FRESH|FROZEN|CANNED|DRIED|RAW|COOKED)\b/gi, '')
      .replace(/\b(PREMIUM|SELECT|CHOICE|GRADE\s+A|NATURAL|FREE\s+RANGE)\b/gi, '')
      .replace(/\b(EACH|EA|PKG|PACKAGE|BAG|BOX|BOTTLE|CAN|JAR|CT|COUNT)\b/gi, '')
      .replace(/\b(LB|LBS|OZ|OUNCE|POUND|GALLON|GAL|QUART|QT)\b/gi, '')
      .replace(/\b(FAMILY\s+SIZE|LARGE|MEDIUM|SMALL|MINI|EXTRA\s+LARGE)\b/gi, '')
      
      // Remove special characters and normalize spacing
      .replace(/[^\w\s]/g, ' ') // Replace special chars with spaces
      .replace(/\s+/g, ' ') // Multiple spaces to single
      .trim();

    // Apply OCR corrections
    cleaned = OCRCorrection.correctItemName(cleaned);
    
    // Final validation and cleanup
    if (!ReceiptFilters.isValidItemName(cleaned)) {
      return '';
    }
    
    return cleaned;
  }
}

// ============= MAIN OCR SERVICE =============
export class OCRService {
  private worker: Tesseract.Worker | null = null;

  async initialize(): Promise<void> {
    if (this.worker) return;
    
    this.worker = await createWorker('eng');
    await this.worker.setParameters({
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,@$-',
    });
  }

  async processReceipt(imageFile: File): Promise<{ items: FoodItem[]; rawText: string }> {
    await this.initialize();
    
    if (!this.worker) {
      throw new Error('OCR worker not initialized');
    }

    const { data: { text } } = await this.worker.recognize(imageFile);
    const items = this.parseReceiptText(text);
    
    return { items, rawText: text };
  }

  private parseReceiptText(text: string): FoodItem[] {
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    const items: FoodItem[] = [];
    
    for (const line of lines) {
      const parsedItem = this.parseReceiptLine(line);
      if (parsedItem) {
        items.push(parsedItem);
      }
    }
    
    return items;
  }

  private parseReceiptLine(line: string): FoodItem | null {
    // Skip lines that are obviously not food items
    if (ReceiptFilters.isNonFoodLine(line)) {
      return null;
    }
    
    // Try different parsers in order of specificity
    let parsed: ParsedReceiptLine | null = null;
    
    // Store-specific parsers first (most reliable)
    parsed = ReceiptParsers.parseKrogerLine(line) ||
             ReceiptParsers.parseWalmartLine(line) ||
             ReceiptParsers.parseTargetLine(line);
    
    // Format-specific parsers
    if (!parsed) {
      parsed = ReceiptParsers.parseWeightBasedLine(line) ||
               ReceiptParsers.parsePLULine(line);
    }
    
    // Generic parsers
    if (!parsed) {
      parsed = ReceiptParsers.parseGenericLine(line);
    }
    
    // Smart parser as last resort (most permissive)
    if (!parsed) {
      parsed = SmartParser.parseAnyLine(line);
    }
    
    if (!parsed) return null;
    
    // Additional validation
    if (!ReceiptFilters.isValidItemName(parsed.itemName)) {
      return null;
    }
    
    // Skip if likely OCR misread
    if (OCRCorrection.isLikelyMisread(parsed.itemName)) {
      return null;
    }
    
    // Get food data and calculate freshness
    const foodData = findFoodItem(parsed.itemName);
    if (!foodData && !parsed.isVerifiedFood) {
      // If not verified as food and not in database, skip
      return null;
    }
    
    const shelfLife = foodData?.shelfLife || 7; // Default 7 days
    const category = foodData?.category || 'Other';
    
    const purchaseDate = new Date();
    const expirationDate = new Date();
    expirationDate.setDate(purchaseDate.getDate() + shelfLife);
    
    // Calculate freshness based on shelf life
    const daysUntilExpiration = Math.ceil((expirationDate.getTime() - purchaseDate.getTime()) / (1000 * 60 * 60 * 24));
    let freshness: 'fresh' | 'warning' | 'expired';
    
    if (daysUntilExpiration <= 0) {
      freshness = 'expired';
    } else if (daysUntilExpiration <= Math.ceil(shelfLife * 0.3)) {
      freshness = 'warning';
    } else {
      freshness = 'fresh';
    }
    
    return {
      id: Math.random().toString(36).substr(2, 9),
      name: parsed.itemName,
      quantity: parsed.quantity,
      purchaseDate,
      expirationDate,
      freshness,
      category,
      confidence: parsed.isVerifiedFood ? 0.9 : 0.7
    };
  }

  async cleanup(): Promise<void> {
    if (this.worker) {
      await this.worker.terminate();
      this.worker = null;
    }
  }
}

// Export singleton instance
export const ocrService = new OCRService();